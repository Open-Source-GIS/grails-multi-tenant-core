<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2. Multi-Tenant Modes</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="2. Multi-Tenant Modes">2. Multi-Tenant Modes</a></h1>The webapp always runs in multi-tenant mode, but you have the choice on how your database will operate. You can choose either one database per customer (single-tenant), or one database for all customers (multi-tenant).<p class="paragraph"/>In Config.groovy, add the following section:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span> // OR <span class="java&#45;quote">"multiTenant"</span>
&#125;</pre></div><p class="paragraph"/>{warn}multiTenant is the default{warn}<h2><a name="2.1 Multi-Tenant Database Set Up">2.1 Multi-Tenant Database Set Up</a></h2><h2>Annotate Domain Classes</h2><p class="paragraph"/>As of 0.10, you only have to annotate domain classes that you want to be multi-tenant. Any domain classes that you want to be shared, such as acegi Role/Requestmap can be left without the annotation.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.groovy.compiler.MultiTenant;<p class="paragraph"/>@MultiTenant class MyDomainClass &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Because the plugin hooks into the compiler, make sure to do a "grails clean" after you've annotated your classes. Eventually, we'd like to get rid of this step.<p class="paragraph"/><h2>A note on indexing in multi-tenant environment</h2><p class="paragraph"/>Indexing a multi-tenant database is a tricky beast. If you have large datasets (100MM-1BB), prepare yourself for some fun. Google multi-tenant databases and start reading. :)<p class="paragraph"/>The short of it is that it's probably most efficient to create multi-column indexes that always include tenantId, that way the db can limit the working set to a single tenant before it starts filtering on another field.<h2><a name="2.2 Single Tenant Database Set Up">2.2 Single Tenant Database Set Up</a></h2>The single-tenant option is a little more immature than the multi-tenant option. It inherits all datasource configuration from the default datasource in Datasource.groovy, and allows you to provide a custom datasource url per tenant. This means that you can't mix and match drivers or user/pass combos for different tenants in the same instance.<p class="paragraph"/>{warn}
TenantUtils.doWithTenant and currentTenant.set() do not work in single tenant mode, unless you manually create a new hibernate session and bind it to the current thread.<p class="paragraph"/>Also, normal second-level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You'll need to use a multi-tenant wrapper for your cache implementation (see below)
{warn}<p class="paragraph"/>The plugin supports the following types of datasources: 
<ul class="star">
<li>jndi</li>
<li>pooled (dbcp)</li>
<li>regular (DriverManagerDataSource)</li>
<li>TransactionAwareDataSourceProxy (Default for 1.3.X JNDI support only for now.)</li>
</ul><p class="paragraph"/><h2>Resolving the DataSource</h2><p class="paragraph"/>Note: Everywhere in the documentation that you see a datasource url, you can also use a jndiName. If the system encounters a tenant you haven't mapped, it will use the default datasource configuration in Datasource.groovy. This includes all database operations that happen before grails is completely loaded.<p class="paragraph"/><h3>Mapping DataSources through Config.groovy</h3><p class="paragraph"/>To map datasource urls in Config.groovy, add the following code:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"config"</span> //This is the <span class="java&#45;keyword">default</span> and can be omitted
    dataSourceTenantMap &#123;<p class="paragraph"/>        //The <span class="java&#45;quote">"t"</span> before the tenantId is required because you can't have a 
        //variable that's a number 
        t1 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev1"</span> 
        t2 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev2"</span> 
        t3 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev3"</span><p class="paragraph"/>        //JNDI Example 
        t1 = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>Mapping DataSources through the database</h3><p class="paragraph"/>Mapping data sources through the database allows them to be provisioned on the fly without any restarting or reloading.<p class="paragraph"/>Add the following line to Config.groovy<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"db"</span> 
&#125;</pre></div><p class="paragraph"/>Then run the following command:<p class="paragraph"/><div class="code"><pre>grails create&#45;data&#45;source&#45;map</pre></div><p class="paragraph"/>This will create a domain class used to store the mappings (tenant.DataSourceTenantMap). You can add a new mapping on the fly like this:<p class="paragraph"/><div class="code"><pre>def dsMap = <span class="java&#45;keyword">new</span> DataSourceTenantMap()
dsMap.mappedTenantId = 5
dsMap.dataSource = <span class="java&#45;quote">"jdbc:mysql://myserver/customerdb"</span><p class="paragraph"/>//Jndi Example
//dsMap.dataSource = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
dsMap.save()</pre></div><p class="paragraph"/>When the record is saved, the datasource resolver will be automatically updated, and the app can start accessing the new datasource immediately<p class="paragraph"/><h2>2nd-Level Caching</h2><p class="paragraph"/>As mentioned above, regular 2nd level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You will need to use a special wrapped version of the cache that makes it tenant-aware. The wrapped versions should maintain all your settings, but each tenant will maintain its OWN cache instances. This means that if can't simply set cache settings to be applied to the entire JVM; you'll have to 'divide' the settings among tenants. To set this update your datasource.groovy file to set<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider'</pre></div><p class="paragraph"/>or<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider'</pre></div><p class="paragraph"/><h3>OSCache </h3><p class="paragraph"/>If you use the OpenSymphony cache provider (org.hibernate.cache.OSCacheProvider), you should use <strong class="bold">grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider</strong> instead.<p class="paragraph"/><h3>EHCache(New with 0.18)</h3><p class="paragraph"/>If you are using the EHCache cache provider your should use <strong class="bold">grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider</strong> insead. 
    </body>
</html>
