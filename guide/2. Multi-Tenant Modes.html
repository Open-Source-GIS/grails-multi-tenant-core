<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2. Multi-Tenant Modes</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="2. Multi-Tenant Modes">2. Multi-Tenant Modes</a></h1>The webapp always runs in multi-tenant mode, but you have the choice on how your database will operate. You can choose either one database per customer (single-tenant), or one database for all customers (multi-tenant).<p class="paragraph"/>In Config.groovy, add the following section:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span> // OR <span class="java&#45;quote">"multiTenant"</span>
&#125;</pre></div><p class="paragraph"/><blockquote class="warning">multiTenant is the default</blockquote><h2><a name="2.1 Multi-Tenant Database Set Up">2.1 Multi-Tenant Database Set Up</a></h2>The 'multiTenant' mode relies your application to use just one database for all tenants running. This is useful when you have a SaaS that allows user to sign up online and have their tenants running just after signing up. This is the simpler approach on multi-tenancy.<p class="paragraph"/>First thing to do, is to tell the plugin witch classes will be treated as multi-tenant ones. You can do it, but annotating your domain classes with the <strong class="bold">@MultiTenant</strong> annotation, as show below:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.groovy.compiler.MultiTenant<p class="paragraph"/>@MultiTenant
class MyDomainClass &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>This way, each instance of MyDomainClass will belong to some tenant. To achieve this, the plugin hooks into all hibernate events that query your database, adding another condition in your queries that will filter just instances of the current tenant.<p class="paragraph"/>For example, imagine you have 2 tenants, each one with 2 instances of MyDomainClass. When the app is running on tenant 1, calling<p class="paragraph"/><div class="code"><pre>def lst = MyDomainClass.list()</pre></div><p class="paragraph"/>will return just its 2 instances, even if you have 4 in your database.<p class="paragraph"/>The plugin hooks either on save/update events, setting the value of tenantId property automagically.<p class="paragraph"/><blockquote class="warning">
You don't need to declare the 'tenantId' property, the plugin even auto-inject it for you, so, keep your domain class code clean
</blockquote><h2><a name="2.1.1 Multi-Tenant mode gotchas">2.1.1 Multi-Tenant mode gotchas</a></h2><h3>A note on indexing in multi-tenant environment</h3><p class="paragraph"/>Indexing a multi-tenant database is a tricky beast. If you have large datasets (100MM-1BB), prepare yourself for some fun. Google 'multi-tenant databases' and start reading. :)<p class="paragraph"/>The short of it is that it's probably most efficient to create multi-column indexes that always include tenantId, that way the db can limit the working set to a single tenant before it starts filtering on another field.<h2><a name="2.2 Single-Tenant Database Set Up">2.2 Single-Tenant Database Set Up</a></h2>The single-tenant option is a little more immature than the multi-tenant option. It inherits all datasource configuration from the default datasource in Datasource.groovy, and allows you to provide a custom datasource url per tenant. This means that you can't mix and match drivers or user/pass combos for different tenants in the same instance.<p class="paragraph"/><blockquote class="warning">
TenantUtils.doWithTenant and currentTenant.set() do not work in single tenant mode, unless you manually create a new hibernate session and bind it to the current thread.<p class="paragraph"/>Also, normal second-level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You'll need to use a multi-tenant wrapper for your cache implementation (see below)
</blockquote><p class="paragraph"/>The plugin supports the following types of datasources: 
<ul class="star">
<li>jndi</li>
<li>pooled (dbcp)</li>
<li>regular (DriverManagerDataSource)</li>
<li>TransactionAwareDataSourceProxy (Default for 1.3.X JNDI support only for now.)</li>
</ul><p class="paragraph"/><h2>Resolving the DataSource</h2><p class="paragraph"/>Note: Everywhere in the documentation that you see a datasource url, you can also use a jndiName. If the system encounters a tenant you haven't mapped, it will use the default datasource configuration in Datasource.groovy. This includes all database operations that happen before grails is completely loaded.<p class="paragraph"/><h3>Mapping DataSources through Config.groovy</h3><p class="paragraph"/>To map datasource urls in Config.groovy, add the following code:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"config"</span> //This is the <span class="java&#45;keyword">default</span> and can be omitted
    dataSourceTenantMap &#123;<p class="paragraph"/>        //The <span class="java&#45;quote">"t"</span> before the tenantId is required because you can't have a 
        //variable that's a number 
        t1 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev1"</span> 
        t2 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev2"</span> 
        t3 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev3"</span><p class="paragraph"/>        //JNDI Example 
        t1 = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>Mapping DataSources through the database</h3><p class="paragraph"/>Mapping data sources through the database allows them to be provisioned on the fly without any restarting or reloading.<p class="paragraph"/>Add the following line to Config.groovy<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"db"</span> 
&#125;</pre></div><p class="paragraph"/>Then run the following command:<p class="paragraph"/><div class="code"><pre>grails create&#45;data&#45;source&#45;map</pre></div><p class="paragraph"/>This will create a domain class used to store the mappings (tenant.DataSourceTenantMap). You can add a new mapping on the fly like this:<p class="paragraph"/><div class="code"><pre>def dsMap = <span class="java&#45;keyword">new</span> DataSourceTenantMap()
dsMap.mappedTenantId = 5
dsMap.dataSource = <span class="java&#45;quote">"jdbc:mysql://myserver/customerdb"</span><p class="paragraph"/>//Jndi Example
//dsMap.dataSource = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
dsMap.save()</pre></div><p class="paragraph"/>When the record is saved, the datasource resolver will be automatically updated, and the app can start accessing the new datasource immediately<p class="paragraph"/><h2>2nd-Level Caching</h2><p class="paragraph"/>As mentioned above, regular 2nd level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You will need to use a special wrapped version of the cache that makes it tenant-aware. The wrapped versions should maintain all your settings, but each tenant will maintain its OWN cache instances. This means that if can't simply set cache settings to be applied to the entire JVM; you'll have to 'divide' the settings among tenants. To set this update your datasource.groovy file to set<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider'</pre></div><p class="paragraph"/>or<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider'</pre></div><p class="paragraph"/><h3>OSCache </h3><p class="paragraph"/>If you use the OpenSymphony cache provider (org.hibernate.cache.OSCacheProvider), you should use <strong class="bold">grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider</strong> instead.<p class="paragraph"/><h3>EHCache(New with 0.18)</h3><p class="paragraph"/>If you are using the EHCache cache provider your should use <strong class="bold">grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider</strong> insead. 
    </body>
</html>
