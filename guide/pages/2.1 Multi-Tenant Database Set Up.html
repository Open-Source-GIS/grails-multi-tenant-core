<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2.1 Multi-Tenant Database Set Up</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    The 'multiTenant' mode relies your application to use just one database for all tenants running. This is useful when you have a SaaS that allows user to sign up online and have their tenants running just after signing up. This is the simpler approach on multi-tenancy.<p class="paragraph"/>First thing to do, is to tell the plugin witch classes will be treated as multi-tenant ones. You can do it, but annotating your domain classes with the <strong class="bold">@MultiTenant</strong> annotation, as show below:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.groovy.compiler.MultiTenant<p class="paragraph"/>@MultiTenant
class MyDomainClass &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>This way, each instance of MyDomainClass will belong to some tenant. To achieve this, the plugin hooks into all hibernate events that query your database, adding another condition in your queries that will filter just instances of the current tenant.<p class="paragraph"/>For example, imagine you have 2 tenants, each one with 2 instances of MyDomainClass. When the app is running on tenant 1, calling<p class="paragraph"/><div class="code"><pre>def lst = MyDomainClass.list()</pre></div><p class="paragraph"/>will return just its 2 instances, even if you have 4 in your database.<p class="paragraph"/>The plugin hooks either on save/update events, setting the value of tenantId property automagically.<p class="paragraph"/><blockquote class="warning">
You don't need to declare the 'tenantId' property, the plugin even auto-inject it for you, so, keep your domain class code clean
</blockquote>
    </body>
</html>
