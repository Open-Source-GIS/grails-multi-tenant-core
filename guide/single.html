<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Grails Multi-Tenant-Core Plugin 1.0.4 - Reference Documentation</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Style" charset="utf-8"/>
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    </head>
    <body class="body">
        <div id="header">
            <div class="images"><br/><br/>
                <a href="http://grails.org" target="_blank"><img alt="The Grails Framework" src="../img/grails.png" border="0"/></a>
                <span style="right:30px; top:20px; position:absolute;">
                    <a href="../index.html" target="_top">Frames</a> | <a href="index.html" target="_top">No Frames</a><br/><br/>
                    <a href="http://springsource.com" target="_blank"><img alt="SpringSource - A Division of VMware" src="../img/springsource-logo.png" border="0"/></a>
                </span>
            </div>
            <div class="message">multiTenantCore</div>
            <h1>Grails Multi-Tenant-Core Plugin - Reference Documentation</h1>
            <p><strong>Authors:</strong> Eric Martineau, Scott Ryan, Lucas Teixeira</p>
            <p><strong>Version:</strong> 1.0.4</p>
            <em></em>
        </div>

        <div id="toc">
            <h2>Table of Contents</h2>
            <div class="tocItem" style="margin-left:0px"><a href="#1. Overview">1. Overview</a></div><div class="tocItem" style="margin-left:10px"><a href="#1.1 Our goal">1.1 Our goal</a></div><div class="tocItem" style="margin-left:0px"><a href="#2. Multi-Tenant Modes">2. Multi-Tenant Modes</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.1 Multi-Tenant Database Set Up">2.1 Multi-Tenant Database Set Up</a></div><div class="tocItem" style="margin-left:10px"><a href="#2.2 Single Tenant Database Set Up">2.2 Single Tenant Database Set Up</a></div><div class="tocItem" style="margin-left:0px"><a href="#3 Spring Integration">3 Spring Integration</a></div><div class="tocItem" style="margin-left:0px"><a href="#3. Configure a Tenant Resolver">3. Configure a Tenant Resolver</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.1 DNS Resolver Set Up">3.1 DNS Resolver Set Up</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.2 Acegi Resolver Set Up">3.2 Acegi Resolver Set Up</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.3 Custom Tenant Resolver">3.3 Custom Tenant Resolver</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.4 Manually changing tenant">3.4 Manually changing tenant</a></div><div class="tocItem" style="margin-left:10px"><a href="#3.5 Tenant Status Checker">3.5 Tenant Status Checker</a></div><div class="tocItem" style="margin-left:0px"><a href="#4. Behind the scenes">4. Behind the scenes</a></div><div class="tocItem" style="margin-left:0px"><a href="#5. Release Notes">5. Release Notes</a></div>
        </div>
        <div id="content">
            <h1><a name="1. Overview">1. Overview</a></h1>The grails multi-tenant plugin allows you to run multiple "customers" (or tenants) from one installation of a grails application with minimum configuration. Application developers who would normally have to install multiple instance of their grails app (one-per-customer) and maintain multiple databases (one-per-customer) can use this plugin to run multiple customers from the same application AND database. The plugin also supports a single-tenant database configuration (one webapp for all tenants, but a datasource for each tenant)<h2><a name="1.1 Our goal">1.1 Our goal</a></h2>We want the plugin to be as non-intrusive and easy to use as possible. You should write your application as if it's for one customer, and the plugin should convert all necessary resources to multi-tenant as needed.<h1><a name="2. Multi-Tenant Modes">2. Multi-Tenant Modes</a></h1>The webapp always runs in multi-tenant mode, but you have the choice on how your database will operate. You can choose either one database per customer (single-tenant), or one database for all customers (multi-tenant).<p class="paragraph"/>In Config.groovy, add the following section:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span> // OR <span class="java&#45;quote">"multiTenant"</span>
&#125;</pre></div><p class="paragraph"/>{warn}multiTenant is the default{warn}<h2><a name="2.1 Multi-Tenant Database Set Up">2.1 Multi-Tenant Database Set Up</a></h2><h2>Annotate Domain Classes</h2><p class="paragraph"/>As of 0.10, you only have to annotate domain classes that you want to be multi-tenant. Any domain classes that you want to be shared, such as acegi Role/Requestmap can be left without the annotation.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.groovy.compiler.MultiTenant;<p class="paragraph"/>@MultiTenant class MyDomainClass &#123;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Because the plugin hooks into the compiler, make sure to do a "grails clean" after you've annotated your classes. Eventually, we'd like to get rid of this step.<p class="paragraph"/><h2>A note on indexing in multi-tenant environment</h2><p class="paragraph"/>Indexing a multi-tenant database is a tricky beast. If you have large datasets (100MM-1BB), prepare yourself for some fun. Google multi-tenant databases and start reading. :)<p class="paragraph"/>The short of it is that it's probably most efficient to create multi-column indexes that always include tenantId, that way the db can limit the working set to a single tenant before it starts filtering on another field.<h2><a name="2.2 Single Tenant Database Set Up">2.2 Single Tenant Database Set Up</a></h2>The single-tenant option is a little more immature than the multi-tenant option. It inherits all datasource configuration from the default datasource in Datasource.groovy, and allows you to provide a custom datasource url per tenant. This means that you can't mix and match drivers or user/pass combos for different tenants in the same instance.<p class="paragraph"/>{warn}
TenantUtils.doWithTenant and currentTenant.set() do not work in single tenant mode, unless you manually create a new hibernate session and bind it to the current thread.<p class="paragraph"/>Also, normal second-level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You'll need to use a multi-tenant wrapper for your cache implementation (see below)
{warn}<p class="paragraph"/>The plugin supports the following types of datasources: 
<ul class="star">
<li>jndi</li>
<li>pooled (dbcp)</li>
<li>regular (DriverManagerDataSource)</li>
<li>TransactionAwareDataSourceProxy (Default for 1.3.X JNDI support only for now.)</li>
</ul><p class="paragraph"/><h2>Resolving the DataSource</h2><p class="paragraph"/>Note: Everywhere in the documentation that you see a datasource url, you can also use a jndiName. If the system encounters a tenant you haven't mapped, it will use the default datasource configuration in Datasource.groovy. This includes all database operations that happen before grails is completely loaded.<p class="paragraph"/><h3>Mapping DataSources through Config.groovy</h3><p class="paragraph"/>To map datasource urls in Config.groovy, add the following code:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"config"</span> //This is the <span class="java&#45;keyword">default</span> and can be omitted
    dataSourceTenantMap &#123;<p class="paragraph"/>        //The <span class="java&#45;quote">"t"</span> before the tenantId is required because you can't have a 
        //variable that's a number 
        t1 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev1"</span> 
        t2 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev2"</span> 
        t3 = <span class="java&#45;quote">"jdbc:mysql://localhost/ets_dev3"</span><p class="paragraph"/>        //JNDI Example 
        t1 = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>Mapping DataSources through the database</h3><p class="paragraph"/>Mapping data sources through the database allows them to be provisioned on the fly without any restarting or reloading.<p class="paragraph"/>Add the following line to Config.groovy<p class="paragraph"/><div class="code"><pre>tenant &#123;
    mode = <span class="java&#45;quote">"singleTenant"</span>
    datasourceResolver.type = <span class="java&#45;quote">"db"</span> 
&#125;</pre></div><p class="paragraph"/>Then run the following command:<p class="paragraph"/><div class="code"><pre>grails create&#45;data&#45;source&#45;map</pre></div><p class="paragraph"/>This will create a domain class used to store the mappings (tenant.DataSourceTenantMap). You can add a new mapping on the fly like this:<p class="paragraph"/><div class="code"><pre>def dsMap = <span class="java&#45;keyword">new</span> DataSourceTenantMap()
dsMap.mappedTenantId = 5
dsMap.dataSource = <span class="java&#45;quote">"jdbc:mysql://myserver/customerdb"</span><p class="paragraph"/>//Jndi Example
//dsMap.dataSource = <span class="java&#45;quote">"java:comp/env/myDataSource"</span>
dsMap.save()</pre></div><p class="paragraph"/>When the record is saved, the datasource resolver will be automatically updated, and the app can start accessing the new datasource immediately<p class="paragraph"/><h2>2nd-Level Caching</h2><p class="paragraph"/>As mentioned above, regular 2nd level caches will not work in single-tenant mode, as you will get primary key collisions across databases. You will need to use a special wrapped version of the cache that makes it tenant-aware. The wrapped versions should maintain all your settings, but each tenant will maintain its OWN cache instances. This means that if can't simply set cache settings to be applied to the entire JVM; you'll have to 'divide' the settings among tenants. To set this update your datasource.groovy file to set<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider'</pre></div><p class="paragraph"/>or<p class="paragraph"/><div class="code"><pre>cache.provider_class = 'grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider'</pre></div><p class="paragraph"/><h3>OSCache </h3><p class="paragraph"/>If you use the OpenSymphony cache provider (org.hibernate.cache.OSCacheProvider), you should use <strong class="bold">grails.plugin.multitenant.oscache.cache.MultiTenantOSCacheProvider</strong> instead.<p class="paragraph"/><h3>EHCache(New with 0.18)</h3><p class="paragraph"/>If you are using the EHCache cache provider your should use <strong class="bold">grails.plugin.multitenant.ehcache.cache.MultiTenantEhCacheProvider</strong> insead. <h1><a name="3 Spring Integration">3 Spring Integration</a></h1>Some of your beans may contain state that needs to be unique per tenant. A good example of this might be a bean that contains a cache, where they key in the cache would result in collisions if it were shared among all tenants.<p class="paragraph"/>With this plugin, you can write the beans as if they are for only one tenant, and the plugin will manage a copy of the bean for each tenant for you and make sure the correct instance is used in the appropriate places. Mark each stateful spring bean as "uniquePerTenant" as follows:<p class="paragraph"/><div class="code"><pre>class SomeStatefulBean <span class="java&#45;keyword">implements</span> SomeStatefulBeanInterface &#123;<p class="paragraph"/>    <span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> <span class="java&#45;object">boolean</span> uniquePerTenant = <span class="java&#45;keyword">true</span><p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Because of the way Spring AOP works, you have to create an interface for your spring bean and make sure you are wiring the interface, not the implementation itself.<p class="paragraph"/>Sometimes, you may not have access to the source code to add "public static boolean uniquePerTenant = true" to the spring bean. You can still make the bean unique by adding the name of the bean to the "tenant.uniquePerTenantBeans" property in Config.groovy:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    uniquePerTenantBeans = &#91;<span class="java&#45;quote">"beanName1"</span>, <span class="java&#45;quote">"beanName2"</span>&#93;
&#125;</pre></div><h1><a name="3. Configure a Tenant Resolver">3. Configure a Tenant Resolver</a></h1>A tenant resolver is the mechanism that figures out who the current tenant is. The plugin ships with two ways of doing this, and you can also implement your own.<h2><a name="3.1 DNS Resolver Set Up">3.1 DNS Resolver Set Up</a></h2>The plugin reads a property named "tenant.resolver.type" to know how to resolve the current tenant. The DNS resolver is the default resolver for the plugin, but this is how you would specify it in Config.groovy:<p class="paragraph"/><div class="code"><pre>tenant &#123; 
    resolver.type = <span class="java&#45;quote">"request"</span> 
&#125;</pre></div><p class="paragraph"/><h2>Mapping subdomains using Config.groovy</h2><p class="paragraph"/>The easiest (and default) behavior is to simply map subdomains (or domains) to tenantIds in Config.groovy. Whenever a request comes in for a matching DNS entry, that tenantId will be set. Managing DNS is a pain, but you can easily add a wildcard DNS entry, then allocate subdomains on the fly without any propagation or updating to/from the DNS server:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    resolver.request.dns.type = <span class="java&#45;quote">"config"</span>  //This is the <span class="java&#45;keyword">default</span>
    domainTenantMap &#123;
        client1.myco.com = 1
        client2.com = 2
        client3.myco.com = 3
    &#125;
&#125;</pre></div><p class="paragraph"/><h2>Mapping subdomains using the database</h2><p class="paragraph"/>Mapping subdomains in Config.groovy works great if your tenant mapping is static. However, if you want customers to be able to sign up automatically online, you can use a database-based tenant resolver by adding the following to your Config.groovy:<p class="paragraph"/><div class="code"><pre>tenant &#123; 
    resolver.request.dns.type = <span class="java&#45;quote">"db"</span> 
&#125;</pre></div><p class="paragraph"/>The plugin provides a command to install a domain class that will be used to store the dns/tenant mappings. Adding rows to the DomainTenantMap table will add those mappings on-the-fly (no restart required)<p class="paragraph"/><div class="code"><pre>grails create&#45;dns&#45;map</pre></div><p class="paragraph"/><h2>Security and TenantId</h2><p class="paragraph"/>{warn}
One advantage of identifying tenants by domain name is that any session cookies will be unique per domain, helping with security. This means that if a user authenticates (and gets an authentication cookie), if he changes the domain he's using to access the application, he won't stay logged on because the cookie for the old domain won't apply.<p class="paragraph"/>This does have a loophole, though. Because the cookie lives on the client browser, it may be possible for the user to inspect the cookie, and copy any values such as jsessionid to a cookie for a different domain, thus gaining access to another tenant's data. It really depends on how secure your cookie is (does an authentication token only work for one domain?)<p class="paragraph"/>The multi-tenant plugin uses a very simple messaging system from the falcone-util plugin. Whenever the tenantId changes, a message is published with the new and old tenantIds. You can use this event to perform any necessary checks, and clean up any resources you don't want around when the tenantId changes. Example as follows:
{warn}<p class="paragraph"/><div class="code"><pre>//A sample class that might contain an authenticated user
class AuthenticatedUser &#123;<p class="paragraph"/>    //Wire in the eventBroker bean &#45; <span class="java&#45;keyword">this</span> is where events are published from and subscribed to 
    GroovyEventBroker eventBroker<p class="paragraph"/>    <span class="java&#45;keyword">public</span> AuthenticatedUser() &#123;<p class="paragraph"/>        //Somewhere in your code, subscribe to the tenantChanged event 
        //Call subscribe method on eventBroker, provide a closure as an event handler<p class="paragraph"/>        eventBroker.subscribe(<span class="java&#45;quote">"tenantChanged"</span>) &#123; event, broker &#45;&#62; 
            <span class="java&#45;keyword">if</span>(<span class="java&#45;keyword">this</span>.tenantId != event.newTenantId) &#123; 
                <span class="java&#45;keyword">this</span>.logout() 
            &#125;
        &#125;
    &#125;
&#125;</pre></div><h2><a name="3.2 Acegi Resolver Set Up">3.2 Acegi Resolver Set Up</a></h2>To make the multi-tenant plugin work with acegi, you have to install an additional plugin<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin multi&#45;tenant&#45;acegi</pre></div><p class="paragraph"/><h2> Config.groovy</h2><p class="paragraph"/>Your tenant resolver property should look like this:<p class="paragraph"/><div class="code"><pre>tenant &#123;
    resolver.type = <span class="java&#45;quote">"acegi"</span>
&#125;</pre></div><p class="paragraph"/><h2>User domain class</h2><p class="paragraph"/>Whichever User domain class you are using with the acegi plugin should have a property on it called "userTenantId". You will have to manually set this value for each user correctly. Note that you should not annotate your User domain class with <code>MultiTenant.<p class="paragraph"/><h2>Role and Requestmap domain class</h2><p class="paragraph"/>Note that Role and Requestmap domain classes will keep annotated with </code>MultiTenant, the same as the other domain classes. <h2><a name="3.3 Custom Tenant Resolver">3.3 Custom Tenant Resolver</a></h2>If the domain-name based approach doesn't work for you, you can implement your own TenantResolver by implementing the TenantResolver interface and then adding that class to your spring config:<p class="paragraph"/><div class="code"><pre>beans &#123;
    //Make sure to <span class="java&#45;keyword">import</span>!
    tenantResolver(MyCustomTenantResolver)
&#125;</pre></div><h2><a name="3.4 Manually changing tenant">3.4 Manually changing tenant</a></h2>Occasionally, you will need to perform data operations for a specific tenant. For example, if you have a signup form on your website and you need to create a bunch of default records for the new tenant. There is a utility class you can use to execute a block of code for a specific tenant:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugin.multitenant.core.util.TenantUtils<p class="paragraph"/>...<p class="paragraph"/>//Everything in the following block will be applied to tenantId=15
TenantUtils.doWithTenant(15) &#123;
  Contact c = <span class="java&#45;keyword">new</span> Contact(firstName:<span class="java&#45;quote">"Bob"</span>)
  c.save() //This record will be saved to tenantId=15
&#125;<p class="paragraph"/>//Now the tenantId will be set back to what it was before<p class="paragraph"/>...</pre></div><h2><a name="3.5 Tenant Status Checker">3.5 Tenant Status Checker</a></h2>You will probably want a way to verify that each tenant has access to their application. If you add a bean to spring named "tenantStatusChecker" that implements the "TenantStatusChecker" interface grails.plugin.multitenant.core.TenantStatusChecker, then this plugin will automatically validate each request and redirect to /noaccess.gsp if the tenant doesn't have access.<p class="paragraph"/>This is pretty clunky and we have plans to make it much better in the future&#8230;<h1><a name="4. Behind the scenes">4. Behind the scenes</a></h1>Here's what the plugin does behind the scenes:<p class="paragraph"/><h2> Multi-Tenant Mode</h2>
<ul class="star">
<li>Performs compile time injection to add a "tenantId" column to all domain objects (multi-tenant mode)</li>
<li>Adds a nullable constraint for the tenantId column (to avoid annoying validation failures)</li>
<li>Intercepts and wraps all hibernate Criteria and Query that force filtering on tenantId so that:</li>
<ul class="star">
<li>All GORM functions backed by a Criteria object always return records ONLY for the current tenant (createCriteria, countBy, exists, find, get, list, listOrderBy, withCriteria)</li>
<li>All GORM functions backed by a Query object will inject a named parameter "tenantId" with the current tenantId if a named parameter already exists This is one way you can get around the tenant filtering if you need to.</li>
</ul>
<li>Listens to appropriate hibernate events to check for tenantId:</li>
<ul class="star">
<li>onPreDelete - make sure the record you're deleting matches the current tenantId</li>
<li>onLoad - make sure you the record you are loading matches the current tenantId</li>
<li>onPreUpdate - make sure the record you are updating matches the current tenantId</li>
<li>onPreInsert - set the current tenantId for the record being added.tenantId</li>
</ul></ul><p class="paragraph"/><h2> Single-Tenant Mode</h2>
<ul class="star">
<li>Converts the "dataSource" bean into an AOP proxy that creates a new datasource for each tenant</li>
</ul><p class="paragraph"/><h2> Other</h2>
<ul class="star">
<li>For each spring bean marked as uniquePerTenant:</li>
<ul class="star">
<li>Convert the spring bean definition to prototype (the spring container will need to be able to create a unique instance of the bean for each tenant)</li>
<li>Replaces the original bean definition with a Spring AOP proxy definition. The proxy intercepts each method, locates the appropriate bean for the current tenant (or creates a new one if needed), and delegates the method call to that bean.</li>
</ul>
<li>Adds a request filter for all controllers that binds the value from session.tenantId to a threadLocal variable. All code processed during that thread's execution will apply only to that tenant.</li>
<li>Adds a request filter for development mode only that sets the current session's tenantId by passing a request parameter, __tenantId.</li>
</ul><p class="paragraph"/><h1><a name="5. Release Notes">5. Release Notes</a></h1><ul class="star">
<li>1.0.3 (January 11, 2011)</li>
<ul class="star">
<li>Add InvalidTenantException when Tenant resolver cannot resolve tenant and do not enter the data source resolver</li>
<li>Reset the tenant Id to 0 after leaving the filter even if an exception is thrown to avoid picking up other threads tenants</li>
</ul>
<li>1.0.2 (January 3, 2011)</li>
<ul class="star">
<li>Fix bug with recursive logging decorator GRAILSPLUGINS-2723</li>
<li>Added the ability to configure the full name of the Database Objects to support Domain to Tenant and Data Source to Tenant Mapping</li>
</ul>
<li>1.0.1 (December 26, 2010)</li>
<ul class="star">
<li>Fix bug processing non-annotated domain objects GRAILSPLUGINS-2579</li>
<li>Update the TenantUtils to handle adding a name parameter to the domain name object</li>
<li>Update logging to include the tenant Id or the Tenant name if present</li>
<li>Add methods to TenantUtils to allow retrieval of tenant name if present and to retrieve the DomainTenantMap object</li>
<li>Add Name parameter to the DomainTenaantMap generator</li>
</ul>
<li>1.0.0 - Initial migration from the original multi-tenant plugin to allow better refactoring and to add more components.</li>
</ul><p class="paragraph"/>
        </div>
        <div id="footer">
             
        </div>
    </body>
</html>
